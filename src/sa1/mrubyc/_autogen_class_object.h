/* Auto generated by make_method_table.rb */
#include "_autogen_builtin_symbol.h"

/*===== Object class =====*/
static const mrbc_sym method_symbols_Object[] = {
  MRBC_SYM(NOT),
  MRBC_SYM(NOT_EQ),
  MRBC_SYM(LT_EQ_GT),
  MRBC_SYM(EQ_EQ),
  MRBC_SYM(EQ_EQ_EQ),
  MRBC_SYM(attr_accessor),
  MRBC_SYM(attr_reader),
  MRBC_SYM(block_given_Q),
  MRBC_SYM(class),
  MRBC_SYM(dup),
#if MRBC_USE_STRING
  MRBC_SYM(inspect),
#endif
#if defined(MRBC_DEBUG)
  MRBC_SYM(instance_methods),
#endif
#if defined(MRBC_DEBUG)
  MRBC_SYM(instance_variables),
#endif
  MRBC_SYM(is_a_Q),
  MRBC_SYM(kind_of_Q),
#if defined(MRBC_DEBUG)
#if !defined(MRBC_ALLOC_LIBC)
  MRBC_SYM(memory_statistics),
#endif
#endif
  MRBC_SYM(new),
  MRBC_SYM(nil_Q),
#if defined(MRBC_DEBUG)
  MRBC_SYM(object_id),
#endif
  MRBC_SYM(p),
  MRBC_SYM(print),
#if MRBC_USE_STRING
  MRBC_SYM(printf),
#endif
  MRBC_SYM(puts),
  MRBC_SYM(raise),
#if MRBC_USE_STRING
  MRBC_SYM(sprintf),
#endif
#if MRBC_USE_STRING
  MRBC_SYM(to_s),
#endif
};

static const mrbc_func_t method_functions_Object[] = {
  c_object_not,
  c_object_neq,
  c_object_compare,
  c_object_equal2,
  c_object_equal3,
  c_object_attr_accessor,
  c_object_attr_reader,
  c_object_block_given,
  c_object_class,
  c_object_dup,
#if MRBC_USE_STRING
  c_object_to_s,
#endif
#if defined(MRBC_DEBUG)
  c_object_instance_methods,
#endif
#if defined(MRBC_DEBUG)
  c_object_instance_variables,
#endif
  c_object_kind_of,
  c_object_kind_of,
#if defined(MRBC_DEBUG)
#if !defined(MRBC_ALLOC_LIBC)
  c_object_memory_statistics,
#endif
#endif
  c_object_new,
  c_object_nil,
#if defined(MRBC_DEBUG)
  c_object_object_id,
#endif
  c_object_p,
  c_object_print,
#if MRBC_USE_STRING
  c_object_printf,
#endif
  c_object_puts,
  c_object_raise,
#if MRBC_USE_STRING
  c_object_sprintf,
#endif
#if MRBC_USE_STRING
  c_object_to_s,
#endif
};

struct RBuiltinClass mrbc_class_Object = {
  .sym_id = MRBC_SYM(Object),
  .num_builtin_method = sizeof(method_symbols_Object) / sizeof(mrbc_sym),
  .super = 0,
  .method_link = 0,
#if defined(MRBC_DEBUG)
  .name = "Object",
#endif
  .method_symbols = method_symbols_Object,
  .method_functions = method_functions_Object,
};


/*===== Proc class =====*/
static const mrbc_sym method_symbols_Proc[] = {
  MRBC_SYM(call),
  MRBC_SYM(new),
};

static const mrbc_func_t method_functions_Proc[] = {
  c_proc_call,
  c_proc_new,
};

struct RBuiltinClass mrbc_class_Proc = {
  .sym_id = MRBC_SYM(Proc),
  .num_builtin_method = sizeof(method_symbols_Proc) / sizeof(mrbc_sym),
  .super = MRBC_CLASS(Object),
  .method_link = 0,
#if defined(MRBC_DEBUG)
  .name = "Proc",
#endif
  .method_symbols = method_symbols_Proc,
  .method_functions = method_functions_Proc,
};


/*===== NilClass class =====*/
static const mrbc_sym method_symbols_NilClass[] = {
#if MRBC_USE_STRING
  MRBC_SYM(inspect),
#endif
  MRBC_SYM(to_a),
#if MRBC_USE_FLOAT
  MRBC_SYM(to_f),
#endif
  MRBC_SYM(to_h),
  MRBC_SYM(to_i),
#if MRBC_USE_STRING
  MRBC_SYM(to_s),
#endif
};

static const mrbc_func_t method_functions_NilClass[] = {
#if MRBC_USE_STRING
  c_nil_inspect,
#endif
  c_nil_to_a,
#if MRBC_USE_FLOAT
  c_nil_to_f,
#endif
  c_nil_to_h,
  c_nil_to_i,
#if MRBC_USE_STRING
  c_nil_to_s,
#endif
};

struct RBuiltinClass mrbc_class_NilClass = {
  .sym_id = MRBC_SYM(NilClass),
  .num_builtin_method = sizeof(method_symbols_NilClass) / sizeof(mrbc_sym),
  .super = MRBC_CLASS(Object),
  .method_link = 0,
#if defined(MRBC_DEBUG)
  .name = "NilClass",
#endif
  .method_symbols = method_symbols_NilClass,
  .method_functions = method_functions_NilClass,
};


/*===== TrueClass class =====*/
static const mrbc_sym method_symbols_TrueClass[] = {
#if MRBC_USE_STRING
  MRBC_SYM(inspect),
#endif
#if MRBC_USE_STRING
  MRBC_SYM(to_s),
#endif
};

static const mrbc_func_t method_functions_TrueClass[] = {
#if MRBC_USE_STRING
  c_true_to_s,
#endif
#if MRBC_USE_STRING
  c_true_to_s,
#endif
};

struct RBuiltinClass mrbc_class_TrueClass = {
  .sym_id = MRBC_SYM(TrueClass),
  .num_builtin_method = sizeof(method_symbols_TrueClass) / sizeof(mrbc_sym),
  .super = MRBC_CLASS(Object),
  .method_link = 0,
#if defined(MRBC_DEBUG)
  .name = "TrueClass",
#endif
  .method_symbols = method_symbols_TrueClass,
  .method_functions = method_functions_TrueClass,
};


/*===== FalseClass class =====*/
static const mrbc_sym method_symbols_FalseClass[] = {
#if MRBC_USE_STRING
  MRBC_SYM(inspect),
#endif
#if MRBC_USE_STRING
  MRBC_SYM(to_s),
#endif
};

static const mrbc_func_t method_functions_FalseClass[] = {
#if MRBC_USE_STRING
  c_false_to_s,
#endif
#if MRBC_USE_STRING
  c_false_to_s,
#endif
};

struct RBuiltinClass mrbc_class_FalseClass = {
  .sym_id = MRBC_SYM(FalseClass),
  .num_builtin_method = sizeof(method_symbols_FalseClass) / sizeof(mrbc_sym),
  .super = MRBC_CLASS(Object),
  .method_link = 0,
#if defined(MRBC_DEBUG)
  .name = "FalseClass",
#endif
  .method_symbols = method_symbols_FalseClass,
  .method_functions = method_functions_FalseClass,
};
